#Things asked in the assignment pdf
1. For running the benchmark programme for large number of processes i found the avg waiting time to be the maximum for FCFS, then RR, then PBS and lastly MLFQ. Sometimes PBS also performed better than MLFQ like for 20 processes i found the waiting times to be like FCFS > RR > MLFQ > PBS. For smaller n, MLFQ's performance was not at par like for n=10 i found the avg waitng times to be like    MLFQ > FCFS > RR = PBS. So for lower values of processes i am having better performance for RR and FCFS as compared to PBS and MLFQ but for larger number of programes i find MLFQ and PBS to be better.
For lower n
                MLFQ ~ PBS > FCFS > RR 
For larger n
                FCFS > RR > PBS > MLFQ
The comparisons are of avg waiting time for the benchmark programe i have written.
1. "By reliquishing the control of cpu voluntarily, and then adding the process back to the ready queue after io"  , if the process actually had io then there is no point in voluntarily losing control because it will more or less leave control of the cpu for io. So prioritising io intensive processes over cpu intensive programs. But if a cpu intensive programs leaves control of cpu voluntarily then i am prioritising a cpu intensive programe over all programs and it will help me to execute certain highly calculative programs faster.

#Implementation details
1. __waitx__ : To implement this I have added three variables in the existing proc structure __etime, rtime, ctime__ where etime is the end time that is when the process has ended execution that is gone to zombie state. rtime is corresponding to the time it runs on the cpu and ctime is the time when the process was created that is allocated memory. The __end time__ is made to store for each process in the __exit()__ system call because this the place where each process is assigned the __ZOMBIE__ state. __ctime__ is stored in the __allocproc()__ system call because this is the place where it is given its space, and __rtime__ is calculated in the __trap.c__(further called a function from there) as in trap.c we have a switch statement whoose first case is corresponding to the part which runs each time a clock tick occurs.
__time__ : Corresponding to __waitx__ a user command is implemented  that is __time__, which is nothing but utilizes the __waitx__ system call and outputs the waiting and running time for the command passed as an argument to __time__.
1. __ps__ : To implement ps i have made a system call that is __pscall()__ and corresponding to that a file is made that is ps.c which utilises the ps system call and outputs the process related infortmation of each process.
1. __FCFS__ : This was the easiest one to implement as we have already stored the ctime for each process so we just have to search in the ptable for a RUNNABLE process which had the lowest ctime. This is done in the __fcfssched(struct cpu *c)__ function in the __proc.c__ file near original __scheduler()__ function of xv6.
1. __PBS__ : This was also quite easy to do, to implement this one i have stored one more value in the __proc structure__ that is __priority__, which is initialised to __60__ in the __allocproc()__ system call. Now the __scheduler function__ corresponding to the PBS scheduler function is __pbsched(struct cpu *c)__ implemented near original __scheduler() function__. In the scheduler i have to just _look for the process having highest priority_ that is _lowest value of the priority variable_ of each process(defined in the assignment to be like this). After finding such a process i have to just run the process in the traditional way.
**set_priority** : This is a system call implemented to utilise the priority of processes in order to make the best use of priority based scheduler. This system call takes two arguments which are __new_priority__ and __pid__ and it assigns the process with the given pid a new priority value that is new_priority by looking in the ptable for a process with the given pid and return the old priority of the process. To utilise set_priority system call a user programe setPriority is implemented to make a new command that is __setPriority__ which takes two command line arguments.
1. __MLFQ__ : Probably the most difficult part of the assignment, to handle all this i have added some of the variables in the proc structure that are __queue, tick[5], ticksinq, etq__ where __queue__ stores the queue in which the __process is__, __tick[5]__ is an array which stores the __clock ticks it has recieved from the cpu in each of the individual queues__, __ticksinq__ is the number of __clockticks it has recieved contiguously in the queue in which the process currently resides__(used to implement the queue changing thing), __etq is the entry time__ of the process in the current queue. You might be wondering how this will be used to implement a queue data structure, here is the crux i will use the etq variable to find the process which was added first in that particular queue by comparing the etq values of all the process in a queue. Basically i will iterate over all the ptable and find the minimum queue that i could find and then i will find the process with the least etq value. Both these are combined in a single loop in the implementation of the function that is __mlfqsched(struct cpu *c)__ near the original scheduler function of the proc.c file. Ageing is also implemented there only. And the variables like the __tick array__ and the __ticksinq__ variable are __incremented__ in the __trap.c__ file like the rtime variable but i __reinitialise__ them to __appropriate values__ whenever they __require__(as defined in the assignment pdf). Moreover specifically round robin is implemented for the queue 4 as told in the pdf.
1. __benchmark__ : A benchmark userprogramme is built to test the three schedulers in order to compare them currently the benchmark creates 10 programmes and gives the avg waiting time and avg running time of the processes.    